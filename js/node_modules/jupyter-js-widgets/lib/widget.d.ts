import * as Backbone from 'backbone';
import { NativeView } from './nativeview';
import { Widget } from 'phosphor/lib/ui/widget';
import { Message } from 'phosphor/lib/core/messaging';
/**
 * Replace model ids with models recursively.
 */
export declare function unpack_models(value: any, manager: any): any;
export declare class WidgetModel extends Backbone.Model {
    /**
     * The default attributes.
     */
    defaults(): {
        _model_module: string;
        _model_name: string;
        _model_module_version: string;
        _view_module: string;
        _view_name: any;
        _view_module_version: string;
        msg_throttle: number;
    };
    /**
     * Test to see if the model has been synced with the server.
     *
     * #### Notes
     * As of backbone 1.1, backbone ignores `patch` if it thinks the
     * model has never been pushed.
     */
    isNew(): boolean;
    /**
     * Constructor
     *
     * Creates a WidgetModel instance.
     *
     * Parameters
     * ----------
     * widget_manager : WidgetManager instance
     * model_id : string
     *      An ID unique to this model.
     * comm : Comm instance (optional)
     */
    initialize(attributes: any, options: any): void;
    /**
     * Send a custom msg over the comm.
     */
    send(content: any, callbacks: any, buffers?: any): void;
    /**
     * Close model
     */
    close(comm_closed: any): void;
    /**
     * Handle when a widget is closed.
     */
    _handle_comm_closed(msg: any): void;
    /**
     * Handle incoming comm msg.
     */
    _handle_comm_msg(msg: any): any;
    /**
     * Handle when a widget is updated from the backend.
     */
    set_state(state: any): void;
    /**
     * Get the serializable state of the model.
     *
     * If drop_default is thruthy, attributes that are equal to their default
     * values are dropped.
     */
    get_state(drop_defaults: any): any;
    /**
     * Handle status msgs.
     *
     * execution_state : ('busy', 'idle', 'starting')
     */
    _handle_status(msg: any, callbacks: any): void;
    /**
     * Create msg callbacks for a comm msg.
     */
    callbacks(view?: any): any;
    /**
     * Set a value.
     *
     * We just call the super method, in which val and options are optional
     */
    set(key: any, val?: any, options?: any): Backbone.Model;
    /**
     * Handle sync to the back-end.  Called when a model.save() is called.
     *
     * Make sure a comm exists.
     *
     * Parameters
     * ----------
     * method : create, update, patch, delete, read
     *   create/update always send the full attribute set
     *   patch - only send attributes listed in options.attrs, and if we
     *   are queuing up messages, combine with previous messages that have
     *   not been sent yet
     * model : the model we are syncing
     *   will normally be the same as `this`
     * options : dict
     *   the `attrs` key, if it exists, gives an {attr: value} dict that
     *   should be synced, otherwise, sync all attributes.
     *
     */
    sync(method: any, model: any, options?: any): any;
    send_sync_message(attrs: any, callbacks: any): void;
    /**
     * Push this model's state to the back-end
     *
     * This invokes a Backbone.Sync.
     */
    save_changes(callbacks?: any): void;
    /**
     * on_some_change(['key1', 'key2'], foo, context) differs from
     * on('change:key1 change:key2', foo, context).
     * If the widget attributes key1 and key2 are both modified,
     * the second form will result in foo being called twice
     * while the first will call foo only once.
     */
    on_some_change(keys: any, callback: any, context: any): void;
    /**
     * Serialize the model.  See the deserialization function at the top of this file
     * and the kernel-side serializer/deserializer.
     */
    toJSON(options: any): string;
    /**
     * Returns a promise for the deserialized state. The second argument
     * is an instance of widget manager, which is required for the
     * deserialization of widget models.
     */
    static _deserialize_state(state: any, manager: any): Promise<any>;
    /**
     * Returns a promise for the serialized state. The second argument
     * is an instance of widget manager.
     */
    static _serialize_state(state: any, manager: any): Promise<any>;
    static serializers: any;
    widget_manager: any;
    state_change: any;
    _buffered_state_diff: any;
    pending_msgs: any;
    msg_buffer: any;
    state_lock: any;
    views: any;
    comm: any;
    comm_live: boolean;
    model_id: string;
    msg_buffer_callbacks: any;
}
export declare class DOMWidgetModel extends WidgetModel {
    static serializers: any;
    defaults(): any;
}
/**
 * - create_view and remove_view are default functions called when adding or removing views
 * - create_view takes a model and an index and returns a view or a promise for a view for that model
 * - remove_view takes a view and destroys it (including calling `view.remove()`)
 * - each time the update() function is called with a new list, the create and remove
 *   callbacks will be called in an order so that if you append the views created in the
 *   create callback and remove the views in the remove callback, you will duplicate
 *   the order of the list.
 * - the remove callback defaults to just removing the view (e.g., pass in null for the second parameter)
 * - the context defaults to the created ViewList.  If you pass another context, the create and remove
 *   will be called in that context.
 */
export declare class ViewList<T> {
    constructor(create_view: (model: any, index: any) => T | Promise<T>, remove_view: (view: T) => void, context: any);
    initialize(create_view: (model: any, index: any) => T | Promise<T>, remove_view: (view: T) => void, context: any): void;
    /**
     * the create_view, remove_view, and context arguments override the defaults
     * specified when the list is created.
     * after this function, the .views attribute is a list of promises for views
     * if you want to perform some action on the list of views, do something like
     * `Promise.all(myviewlist.views).then(function(views) {...});`
     */
    update(new_models: any, create_view?: (model: any, index: any) => T | Promise<T>, remove_view?: (view: T) => void, context?: any): Promise<T[]>;
    /**
     * removes every view in the list; convenience function for `.update([])`
     * that should be faster
     * returns a promise that resolves after this removal is done
     */
    remove(): Promise<void>;
    /**
     * Dispose this viewlist.
     *
     * A synchronous function which just deletes references to child views. This
     * function does not call .remove() on child views because that is
     * asynchronous. Use this in cases where child views will be removed in
     * another way.
     */
    dispose(): void;
    _handler_context: any;
    _models: any[];
    views: Promise<T>[];
    _create_view: (model: any, index: any) => T | Promise<T>;
    _remove_view: (view: T) => void;
}
export declare abstract class WidgetView extends NativeView<WidgetModel> {
    /**
     * Public constructor.
     */
    initialize(parameters: any): void;
    /**
     * Triggered on model change.
     *
     * Update view to be consistent with this.model
     */
    update(options?: any): void;
    /**
     * Render a view
     *
     * @returns the view or a promise to the view.
     */
    render(): any;
    /**
     * Create and promise that resolves to a child view of a given model
     */
    create_child_view(child_model: any, options?: any): any;
    /**
     * Create msg callbacks for a comm msg.
     */
    callbacks(): any;
    /**
     * Send a custom msg associated with this view.
     */
    send(content: any, buffers?: any): void;
    touch(): void;
    remove(): any;
    options: any;
    /**
     * A promise that resolves to the parent view when a child view is displayed.
     */
    displayed: Promise<WidgetView>;
}
export declare namespace JupyterPhosphorWidget {
    interface IOptions {
        view: DOMWidgetView;
    }
}
export declare class JupyterPhosphorWidget extends Widget {
    constructor(options: Widget.IOptions & JupyterPhosphorWidget.IOptions);
    /**
     * Dispose the widget.
     *
     * This causes the view to be destroyed as well with 'remove'
     */
    dispose(): void;
    /**
     * Process the phosphor message.
     *
     * Any custom phosphor widget used inside a Jupyter widget should override
     * the processMessage function like this.
     */
    processMessage(msg: Message): void;
    private _view;
}
export declare class DOMWidgetView extends WidgetView {
    /**
     * Public constructor
     */
    initialize(parameters: any): void;
    setLayout(layout: any, oldLayout?: any): void;
    setStyle(style: any, oldStyle?: any): void;
    /**
     * Update the DOM classes applied to an element, default to this.el.
     */
    update_classes(old_classes: any, new_classes: any, el?: any): void;
    /**
     * Update the DOM classes applied to the widget based on a single
     * trait's value.
     *
     * Given a trait value classes map, this function automatically
     * handles applying the appropriate classes to the widget element
     * and removing classes that are no longer valid.
     *
     * Parameters
     * ----------
     * class_map: dictionary
     *  Dictionary of trait values to class lists.
     *  Example:
     *      {
     *          success: ['alert', 'alert-success'],
     *          info: ['alert', 'alert-info'],
     *          warning: ['alert', 'alert-warning'],
     *          danger: ['alert', 'alert-danger']
     *      };
     * trait_name: string
     *  Name of the trait to check the value of.
     * el: optional DOM element handle, defaults to this.el
     *  Element that the classes are applied to.
     */
    update_mapped_classes(class_map: any, trait_name: any, el?: any): void;
    set_mapped_classes(class_map: any, trait_name: any, el?: any): void;
    typeset(element: any, text?: any): void;
    _setElement(el: HTMLElement): void;
    remove(): any;
    processPhosphorMessage(msg: Message): void;
    '$el': any;
    pWidget: Widget;
    layoutPromise: Promise<any>;
    stylePromise: Promise<any>;
}
export declare class LabeledDOMWidgetModel extends DOMWidgetModel {
    defaults(): any;
}
export declare class LabeledDOMWidgetView extends DOMWidgetView {
    render(): void;
    updateDescription(): void;
    label: HTMLDivElement;
}
