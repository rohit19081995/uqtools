// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var widget_core_1 = require('./widget_core');
var widget_1 = require('./widget');
var _ = require('underscore');
var utils = require('./utils');
var $ = require('jquery');
function scrollIfNeeded(area, elem) {
    var ar = area.getBoundingClientRect();
    var er = elem.getBoundingClientRect();
    if (er.top < ar.top) {
        area.scrollTop -= ar.top - er.top;
    }
    else if (er.bottom > ar.bottom) {
        area.scrollTop += er.bottom - ar.bottom;
    }
}
var SelectionModel = (function (_super) {
    __extends(SelectionModel, _super);
    function SelectionModel() {
        _super.apply(this, arguments);
    }
    SelectionModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'SelectionModel',
            value: '',
            _options_labels: [],
            disabled: false,
        });
    };
    return SelectionModel;
}(widget_core_1.CoreLabeledDOMWidgetModel));
exports.SelectionModel = SelectionModel;
var SelectModel = (function (_super) {
    __extends(SelectModel, _super);
    function SelectModel() {
        _super.apply(this, arguments);
    }
    SelectModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'SelectModel',
            _view_name: 'SelectView'
        });
    };
    return SelectModel;
}(SelectionModel));
exports.SelectModel = SelectModel;
var SelectView = (function (_super) {
    __extends(SelectView, _super);
    function SelectView() {
        _super.apply(this, arguments);
    }
    /**
     * Public constructor.
     */
    SelectView.prototype.initialize = function (parameters) {
        var _this = this;
        _super.prototype.initialize.call(this, parameters);
        this.listenTo(this.model, 'change:_options_labels', function () { return _this._updateOptions(); });
    };
    /**
     * Called when view is rendered.
     */
    SelectView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-inline-hbox');
        this.el.classList.add('widget-select');
        this.listbox = document.createElement('select');
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
    };
    /**
     * Update the contents of this view
     */
    SelectView.prototype.update = function () {
        // Disable listbox if needed
        this.listbox.disabled = this.model.get('disabled');
        // Select the correct element
        var value = this.model.get('value');
        this.listbox.selectedIndex = this.model.get('_options_labels').indexOf(value);
        return _super.prototype.update.call(this);
    };
    SelectView.prototype._updateOptions = function () {
        this.listbox.textContent = '';
        var items = this.model.get('_options_labels');
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var option = document.createElement('option');
            option.textContent = item.replace(/ /g, '\xa0'); // space -> &nbsp;
            option.setAttribute('data-value', encodeURIComponent(item));
            option.value = item;
            this.listbox.appendChild(option);
        }
    };
    SelectView.prototype.events = function () {
        return {
            'change select': '_handle_change'
        };
    };
    /**
     * Handle when a new value is selected.
     */
    SelectView.prototype._handle_change = function () {
        var value = this.listbox.options[this.listbox.selectedIndex].value;
        this.model.set('value', value);
        this.touch();
    };
    return SelectView;
}(widget_1.LabeledDOMWidgetView));
exports.SelectView = SelectView;
var DropdownModel = (function (_super) {
    __extends(DropdownModel, _super);
    function DropdownModel() {
        _super.apply(this, arguments);
    }
    DropdownModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'DropdownModel',
            _view_name: 'DropdownView',
            button_style: ''
        });
    };
    return DropdownModel;
}(SelectionModel));
exports.DropdownModel = DropdownModel;
// TODO: Make a phosphor dropdown control, wrapped in DropdownView. Also, fix
// bugs in keyboard handling. See
// https://github.com/ipython/ipywidgets/issues/1055 and
// https://github.com/ipython/ipywidgets/issues/1049
// For now, we subclass SelectView to provide DropdownView
// For the old code, see commit f68bfbc566f3a78a8f3350b438db8ed523ce3642
var DropdownView = (function (_super) {
    __extends(DropdownView, _super);
    function DropdownView() {
        _super.apply(this, arguments);
    }
    return DropdownView;
}(SelectView));
exports.DropdownView = DropdownView;
var RadioButtonsModel = (function (_super) {
    __extends(RadioButtonsModel, _super);
    function RadioButtonsModel() {
        _super.apply(this, arguments);
    }
    RadioButtonsModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'RadioButtonsModel',
            _view_name: 'RadioButtonsView',
            tooltips: [],
            icons: [],
            button_style: ''
        });
    };
    return RadioButtonsModel;
}(SelectionModel));
exports.RadioButtonsModel = RadioButtonsModel;
var RadioButtonsView = (function (_super) {
    __extends(RadioButtonsView, _super);
    function RadioButtonsView() {
        _super.apply(this, arguments);
    }
    /**
     * Called when view is rendered.
     */
    RadioButtonsView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-inline-hbox');
        this.el.classList.add('widget-radio');
        this.container = document.createElement('div');
        this.el.appendChild(this.container);
        this.container.classList.add('widget-radio-box');
        this.update();
    };
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    RadioButtonsView.prototype.update = function (options) {
        var view = this;
        var items = this.model.get('_options_labels');
        var radios = _.pluck(this.container.querySelectorAll('input[type="radio"]'), 'value');
        var stale = false;
        for (var i = 0, len = items.length; i < len; ++i) {
            if (radios[i] !== items[i]) {
                stale = true;
                break;
            }
        }
        if (stale && (options === undefined || options.updated_view !== this)) {
            // Add items to the DOM.
            this.container.textContent = '';
            _.each(items, function (item) {
                var label = document.createElement('label');
                label.textContent = item;
                view.container.appendChild(label);
                var radio = document.createElement('input');
                radio.setAttribute('type', 'radio');
                radio.value = item;
                radio.setAttribute('data-value', encodeURIComponent(item));
                label.appendChild(radio);
            });
        }
        _.each(items, function (item) {
            var item_query = 'input[data-value="' +
                encodeURIComponent(item) + '"]';
            var radio = view.container.querySelectorAll(item_query);
            if (radio.length > 0) {
                var radio_el = radio[0];
                radio_el.checked = view.model.get('value') === item;
                radio_el.disabled = view.model.get('disabled');
            }
        });
        return _super.prototype.update.call(this, options);
    };
    RadioButtonsView.prototype.events = function () {
        return {
            'click input[type="radio"]': '_handle_click'
        };
    };
    /**
     * Handle when a value is clicked.
     *
     * Calling model.set will trigger all of the other views of the
     * model to update.
     */
    RadioButtonsView.prototype._handle_click = function (event) {
        var value = event.target.value;
        this.model.set('value', value, { updated_view: this });
        this.touch();
    };
    return RadioButtonsView;
}(widget_1.LabeledDOMWidgetView));
exports.RadioButtonsView = RadioButtonsView;
var ToggleButtonsModel = (function (_super) {
    __extends(ToggleButtonsModel, _super);
    function ToggleButtonsModel() {
        _super.apply(this, arguments);
    }
    ToggleButtonsModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'ToggleButtonsModel',
            _view_name: 'ToggleButtonsView'
        });
    };
    return ToggleButtonsModel;
}(SelectionModel));
exports.ToggleButtonsModel = ToggleButtonsModel;
var ToggleButtonsView = (function (_super) {
    __extends(ToggleButtonsView, _super);
    function ToggleButtonsView() {
        _super.apply(this, arguments);
    }
    ToggleButtonsView.prototype.initialize = function (options) {
        this._css_state = {};
        _super.prototype.initialize.call(this, options);
        this.listenTo(this.model, 'change:button_style', this.update_button_style);
    };
    /**
     * Called when view is rendered.
     */
    ToggleButtonsView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-inline-hbox');
        this.el.classList.add('widget-toggle-buttons');
        this.buttongroup = document.createElement('div');
        this.el.appendChild(this.buttongroup);
        this.update();
        this.set_button_style();
    };
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    ToggleButtonsView.prototype.update = function (options) {
        var view = this;
        var items = this.model.get('_options_labels');
        var icons = this.model.get('icons') || [];
        var previous_icons = this.model.previous('icons') || [];
        var previous_bstyle = ToggleButtonsView.classMap[this.model.previous('button_style')] || '';
        var tooltips = view.model.get('tooltips') || [];
        var disabled = this.model.get('disabled');
        var buttons = this.buttongroup.querySelectorAll('button');
        var values = _.pluck(buttons, 'value');
        var stale = false;
        for (var i = 0, len = items.length; i < len; ++i) {
            if (values[i] !== items[i] || icons[i] !== previous_icons[i]) {
                stale = true;
                break;
            }
        }
        if (stale && options === undefined || options.updated_view !== this) {
            // Add items to the DOM.
            this.buttongroup.textContent = '';
            _.each(items, function (item, index) {
                var item_html;
                var empty = item.trim().length === 0 &&
                    (!icons[index] || icons[index].trim().length === 0);
                if (empty) {
                    item_html = '&nbsp;';
                }
                else {
                    item_html = utils.escape_html(item);
                }
                var icon = document.createElement('i');
                var button = document.createElement('button');
                if (icons[index]) {
                    icon.className = 'fa fa-' + icons[index];
                }
                button.setAttribute('type', 'button');
                button.className = 'widget-toggle-button jupyter-button';
                if (previous_bstyle) {
                    button.classList.add(previous_bstyle);
                }
                button.innerHTML = item_html;
                button.setAttribute('data-value', encodeURIComponent(item));
                button.setAttribute('value', item);
                button.appendChild(icon);
                button.disabled = disabled;
                if (tooltips[index]) {
                    button.setAttribute('title', tooltips[index]);
                }
                view.update_style_traits(button);
                view.buttongroup.appendChild(button);
            });
        }
        // Select active button.
        _.each(items, function (item) {
            var item_query = '[data-value="' + encodeURIComponent(item) + '"]';
            var button = view.buttongroup.querySelector(item_query);
            if (view.model.get('value') === item) {
                button.classList.add('mod-active');
            }
            else {
                button.classList.remove('mod-active');
            }
        });
        return _super.prototype.update.call(this, options);
    };
    ToggleButtonsView.prototype.update_style_traits = function (button) {
        for (var name in this._css_state) {
            if (this._css_state.hasOwnProperty(name)) {
                if (name === 'margin') {
                    this.buttongroup.style[name] = this._css_state[name];
                }
                else if (name !== 'width') {
                    if (button) {
                        button.style[name] = this._css_state[name];
                    }
                    else {
                        var buttons = this.buttongroup
                            .querySelectorAll('button');
                        if (buttons.length) {
                            buttons[0].style[name] = this._css_state[name];
                        }
                    }
                }
            }
        }
    };
    ToggleButtonsView.prototype.update_button_style = function () {
        var _this = this;
        var buttons = this.buttongroup.querySelectorAll('button');
        _.each(buttons, function (button) {
            _this.update_mapped_classes(ToggleButtonsView.classMap, 'button_style', button);
        });
    };
    ToggleButtonsView.prototype.set_button_style = function () {
        var _this = this;
        var buttons = this.buttongroup.querySelectorAll('button');
        _.each(buttons, function (button) {
            _this.set_mapped_classes(ToggleButtonsView.classMap, 'button_style', button);
        });
    };
    ToggleButtonsView.prototype.events = function () {
        return {
            'click button': '_handle_click'
        };
    };
    /**
     * Handle when a value is clicked.
     *
     * Calling model.set will trigger all of the other views of the
     * model to update.
     */
    ToggleButtonsView.prototype._handle_click = function (event) {
        var value = event.target.value;
        this.model.set('value', value, { updated_view: this });
        this.touch();
    };
    return ToggleButtonsView;
}(widget_1.LabeledDOMWidgetView));
exports.ToggleButtonsView = ToggleButtonsView;
var ToggleButtonsView;
(function (ToggleButtonsView) {
    ToggleButtonsView.classMap = {
        primary: ['mod-primary'],
        success: ['mod-success'],
        info: ['mod-info'],
        warning: ['mod-warning'],
        danger: ['mod-danger']
    };
})(ToggleButtonsView = exports.ToggleButtonsView || (exports.ToggleButtonsView = {}));
var SelectionSliderModel = (function (_super) {
    __extends(SelectionSliderModel, _super);
    function SelectionSliderModel() {
        _super.apply(this, arguments);
    }
    SelectionSliderModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'SelectionSliderModel',
            _view_name: 'SelectionSliderView',
            orientation: 'horizontal',
            readout: true,
            continuous_update: true
        });
    };
    return SelectionSliderModel;
}(SelectionModel));
exports.SelectionSliderModel = SelectionSliderModel;
var SelectionSliderView = (function (_super) {
    __extends(SelectionSliderView, _super);
    function SelectionSliderView() {
        _super.apply(this, arguments);
    }
    /**
     * Called when view is rendered.
     */
    SelectionSliderView.prototype.render = function () {
        var _this = this;
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-inline-hbox');
        this.el.classList.add('widget-hslider');
        this.el.classList.add('widget-slider');
        (this.$slider = $('<div />'))
            .slider({
            slide: this.handleSliderChange.bind(this),
            stop: this.handleSliderChanged.bind(this)
        })
            .addClass('slider');
        // Put the slider in a container
        this.slider_container = document.createElement('div');
        this.slider_container.classList.add('slider-container');
        this.slider_container.appendChild(this.$slider[0]);
        this.el.appendChild(this.slider_container);
        this.readout = document.createElement('div');
        this.el.appendChild(this.readout);
        this.readout.classList.add('widget-readout');
        this.readout.style.display = 'none';
        this.listenTo(this.model, 'change:slider_color', function (sender, value) {
            _this.$slider.find('a').css('background', value);
        });
        this.$slider.find('a').css('background', this.model.get('slider_color'));
        // Set defaults.
        this.update();
    };
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    SelectionSliderView.prototype.update = function (options) {
        if (options === undefined || options.updated_view != this) {
            var labels = this.model.get('_options_labels');
            var max = labels.length - 1;
            var min = 0;
            this.$slider.slider('option', 'step', 1);
            this.$slider.slider('option', 'max', max);
            this.$slider.slider('option', 'min', min);
            // WORKAROUND FOR JQUERY SLIDER BUG.
            // The horizontal position of the slider handle
            // depends on the value of the slider at the time
            // of orientation change.  Before applying the new
            // workaround, we set the value to the minimum to
            // make sure that the horizontal placement of the
            // handle in the vertical slider is always
            // consistent.
            var orientation = this.model.get('orientation');
            this.$slider.slider('option', 'value', min);
            this.$slider.slider('option', 'orientation', orientation);
            var value = this.model.get('value');
            var index = labels.indexOf(value);
            this.$slider.slider('option', 'value', index);
            this.readout.textContent = value;
            // Use the right CSS classes for vertical & horizontal sliders
            if (orientation === 'vertical') {
                this.el.classList.remove('widget-hslider');
                this.el.classList.remove('widget-inline-hbox');
                this.el.classList.add('widget-vslider');
                this.el.classList.add('widget-inline-vbox');
            }
            else {
                this.el.classList.remove('widget-vslider');
                this.el.classList.remove('widget-inline-vbox');
                this.el.classList.add('widget-hslider');
                this.el.classList.add('widget-inline-hbox');
            }
            var readout = this.model.get('readout');
            if (readout) {
                // this.$readout.show();
                this.readout.style.display = '';
            }
            else {
                // this.$readout.hide();
                this.readout.style.display = 'none';
            }
        }
        return _super.prototype.update.call(this, options);
    };
    SelectionSliderView.prototype.events = function () {
        return {
            'slide': 'handleSliderChange',
            'slidestop': 'handleSliderChanged'
        };
    };
    /**
     * Called when the slider value is changing.
     */
    SelectionSliderView.prototype.handleSliderChange = function (e, ui) {
        var actual_value = this._validate_slide_value(ui.value);
        var selected_label = this.model.get('_options_labels')[actual_value];
        this.readout.textContent = selected_label;
        // Only persist the value while sliding if the continuous_update
        // trait is set to true.
        if (this.model.get('continuous_update')) {
            this.handleSliderChanged(e, ui);
        }
    };
    /**
     * Called when the slider value has changed.
     *
     * Calling model.set will trigger all of the other views of the
     * model to update.
     */
    SelectionSliderView.prototype.handleSliderChanged = function (e, ui) {
        var actual_value = this._validate_slide_value(ui.value);
        var selected_label = this.model.get('_options_labels')[actual_value];
        this.readout.textContent = selected_label;
        this.model.set('value', selected_label, { updated_view: this });
        this.touch();
    };
    SelectionSliderView.prototype._validate_slide_value = function (x) {
        /**
         * Validate the value of the slider before sending it to the back-end
         * and applying it to the other views on the page.
         */
        return Math.floor(x);
    };
    return SelectionSliderView;
}(widget_1.LabeledDOMWidgetView));
exports.SelectionSliderView = SelectionSliderView;
var MultipleSelectionModel = (function (_super) {
    __extends(MultipleSelectionModel, _super);
    function MultipleSelectionModel() {
        _super.apply(this, arguments);
    }
    MultipleSelectionModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'MultipleSelectionModel',
        });
    };
    return MultipleSelectionModel;
}(SelectionModel));
exports.MultipleSelectionModel = MultipleSelectionModel;
var SelectMultipleModel = (function (_super) {
    __extends(SelectMultipleModel, _super);
    function SelectMultipleModel() {
        _super.apply(this, arguments);
    }
    SelectMultipleModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'SelectMultipleModel',
            _view_name: 'SelectMultipleView'
        });
    };
    return SelectMultipleModel;
}(MultipleSelectionModel));
exports.SelectMultipleModel = SelectMultipleModel;
var SelectMultipleView = (function (_super) {
    __extends(SelectMultipleView, _super);
    function SelectMultipleView() {
        _super.apply(this, arguments);
    }
    /**
     * Public constructor.
     */
    SelectMultipleView.prototype.initialize = function (parameters) {
        var _this = this;
        _super.prototype.initialize.call(this, parameters);
        this.listenTo(this.model, 'change:_options_labels', function () { return _this._updateOptions(); });
    };
    /**
     * Called when view is rendered.
     */
    SelectMultipleView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('widget-inline-hbox');
        this.el.classList.add('widget-select-multiple');
        this.listbox = document.createElement('select');
        this.listbox.multiple = true;
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
    };
    /**
     * Update the contents of this view
     */
    SelectMultipleView.prototype.update = function () {
        _super.prototype.update.call(this);
        this.listbox.disabled = this.model.get('disabled');
        // Set selected values
        var selected = this.model.get('value') || [];
        var values = _.map(selected, encodeURIComponent);
        var options = this.listbox.options;
        for (var i = 0, len = options.length; i < len; ++i) {
            var value = options[i].getAttribute('data-value');
            options[i].selected = _.contains(values, value);
        }
    };
    SelectMultipleView.prototype._updateOptions = function () {
        this.listbox.textContent = '';
        var items = this.model.get('_options_labels');
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var option = document.createElement('option');
            option.textContent = item.replace(/ /g, '\xa0'); // space -> &nbsp;
            option.setAttribute('data-value', encodeURIComponent(item));
            option.value = item;
            this.listbox.appendChild(option);
        }
    };
    SelectMultipleView.prototype.events = function () {
        return {
            'change select': '_handle_change'
        };
    };
    /**
     * Handle when a new value is selected.
     */
    SelectMultipleView.prototype._handle_change = function () {
        // In order to preserve type information correctly, we need to map
        // the selected indices to the options list.
        var items = this.model.get('_options_labels');
        var values = Array.prototype.map
            .call(this.listbox.selectedOptions || [], function (option) {
            return items[option.index];
        });
        this.model.set('value', values);
        this.touch();
    };
    return SelectMultipleView;
}(widget_1.LabeledDOMWidgetView));
exports.SelectMultipleView = SelectMultipleView;
