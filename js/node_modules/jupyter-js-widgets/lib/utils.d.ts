/**
 * http://www.ietf.org/rfc/rfc4122.txt
 */
export declare function uuid(): string;
/**
 * Wrappable Error class
 *
 * The Error class doesn't actually act on `this`.  Instead it always
 * returns a new instance of Error.  Here we capture that instance so we
 * can apply it's properties to `this`.
 */
export declare class WrappedError extends Error {
    constructor(message: any, error: any);
    error_stack: any[];
}
/**
 * Tries to load a class
 *
 * Tries to load a class from a module using require.js, if a module
 * is specified, otherwise tries to load a class from the global
 * registry, if the global registry is provided.
 *
 * The optional require_error argument is a function that takes the success
 * handler and returns a requirejs error handler, which may call the success
 * handler with a fallback module.
 *
 */
export declare function loadClass(class_name: any, module_name: any, module_version: any, registry: any, require_error: any): Promise<any>;
/**
 * Resolve a promiseful dictionary.
 * Returns a single Promise.
 */
export declare function resolvePromisesDict(d: any): Promise<any>;
/**
 * Creates a wrappable Promise rejection function.
 *
 * Creates a function that returns a Promise.reject with a new WrappedError
 * that has the provided message and wraps the original error that
 * caused the promise to reject.
 */
export declare function reject(message: any, log: any): (error: any) => Promise<never>;
/**
 * Apply MathJax rendering to an element, and optionally set its text.
 *
 * If MathJax is not available, make no changes.
 *
 * Parameters
 * ----------
 * element: Node
 * text: optional string
 */
export declare function typeset(element: HTMLElement, text?: string): void;
/**
 * escape text to HTML
 */
export declare function escape_html(text: string): string;
