import { LabeledDOMWidgetView } from './widget';
import { CoreLabeledDOMWidgetModel } from './widget_core';
export declare class StringModel extends CoreLabeledDOMWidgetModel {
    defaults(): any;
}
export declare class HTMLModel extends StringModel {
    defaults(): any;
}
export declare class HTMLView extends LabeledDOMWidgetView {
    /**
     * Called when view is rendered.
     */
    render(): void;
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    update(): void;
    content: HTMLDivElement;
}
export declare class HTMLMathModel extends StringModel {
    defaults(): any;
}
export declare class HTMLMathView extends LabeledDOMWidgetView {
    /**
     * Called when view is rendered.
     */
    render(): void;
    /**
     * Update the contents of this view
     */
    update(): void;
    content: HTMLDivElement;
}
export declare class LabelModel extends StringModel {
    defaults(): any;
}
export declare class LabelView extends LabeledDOMWidgetView {
    /**
     * Called when view is rendered.
     */
    render(): void;
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    update(): void;
}
export declare class TextareaModel extends StringModel {
    defaults(): any;
}
export declare class TextareaView extends LabeledDOMWidgetView {
    /**
     * Called when view is rendered.
     */
    render(): void;
    /**
     * Handle when a custom msg is recieved from the back-end.
     */
    _handle_textarea_msg(content: any): void;
    update_placeholder(value?: any): void;
    /**
     * Scroll the text-area view to the bottom.
     */
    scroll_to_bottom(): void;
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    update(options?: any): void;
    events(): {
        [e: string]: string;
    };
    /**
     * Handle key down
     *
     * Stop propagation so the event isn't sent to the application.
     */
    handleKeyDown(e: any): void;
    /**
     * Handles key press
     *
     * Stop propagation so the keypress isn't sent to the application.
     */
    handleKeypress(e: any): void;
    /**
     * Handles and validates user input.
     *
     * Calling model.set will trigger all of the other views of the
     * model to update.
     */
    handleChanging(e: any): void;
    textbox: HTMLTextAreaElement;
}
export declare class TextModel extends StringModel {
    defaults(): any;
}
export declare class TextView extends LabeledDOMWidgetView {
    /**
     * Called when view is rendered.
     */
    render(): void;
    update_placeholder(value?: any): void;
    update(options?: any): void;
    events(): {
        [e: string]: string;
    };
    /**
     * Handle key down
     *
     * Stop propagation so the keypress isn't sent to the application.
     */
    handleKeyDown(e: any): void;
    /**
     * Handles text submission
     */
    handleKeypress(e: any): void;
    /**
     * Handles user input.
     *
     * Calling model.set will trigger all of the other views of the
     * model to update.
     */
    handleChanging(e: any): void;
    /**
     * Prevent a blur from firing if the blur was not user intended.
     * This is a workaround for the return-key focus loss bug.
     * TODO: Is the original bug actually a fault of the keyboard
     * manager?
     */
    handleBlur(e: any): void;
    /**
     * Prevent a blur from firing if the blur was not user intended.
     * This is a workaround for the return-key focus loss bug.
     */
    handleFocusOut(e: any): void;
    textbox: HTMLInputElement;
}
